//! Convert Turbopack trace files to SPAA format.
//!
//! This module parses binary Turbopack trace files (generated by
//! `NEXT_TURBOPACK_TRACING=1 npm run dev`) and converts them to the
//! SPAA (Stack Profile for Agentic Analysis) format.
//!
//! The Turbopack trace format uses postcard-serialized `TraceRow` events
//! with a `TRACEv0` magic header. Spans form a tree via parent IDs, and
//! CPU self-time is tracked through Enter/Exit events per thread.
//!
//! ## Metadata preservation
//!
//! Turbopack spans carry string args (like file paths, module names) that
//! identify *what* a span is operating on. These are incorporated into the
//! SPAA frame identity so that e.g. `resolve_module [src/app/page.tsx]`
//! appears as a distinct frame from `resolve_module [src/components/Button.tsx]`.
//!
//! Numeric metrics from `Record` events (like `module_count`, `total_size`)
//! are aggregated as additional weights on the stack records.
//!
//! # Example
//!
//! ```no_run
//! use spaa::turbopack::TurbopackConverter;
//! use std::fs::File;
//! use std::io::BufWriter;
//!
//! let mut converter = TurbopackConverter::new();
//! converter.parse_file("trace-turbopack").unwrap();
//! let output = BufWriter::new(File::create("profile.spaa").unwrap());
//! converter.write_spaa(output).unwrap();
//! ```

use spaa_parse::{
    AllocationTracking, Dso, EventDef, EventKind, ExclusiveWeights, Frame, FrameKind, FrameOrder,
    Header, Sampling, SamplingMode, SourceInfo, SpaaWriter, Stack, StackContext, StackIdMode,
    StackType, Thread, TimeRange, Weight,
};
use std::borrow::Cow;
use std::collections::{HashMap, HashSet};
use std::io::{self, BufReader, Read, Write};
use std::path::Path;
use thiserror::Error;

// ── Turbopack trace types (matches turbopack-trace-utils) ──────────────────

#[derive(Debug, serde::Deserialize)]
enum TraceRow<'a> {
    Start {
        ts: u64,
        id: u64,
        parent: Option<u64>,
        #[serde(borrow)]
        name: Cow<'a, str>,
        #[serde(borrow)]
        target: Cow<'a, str>,
        #[serde(borrow)]
        values: Vec<(Cow<'a, str>, TraceValue<'a>)>,
    },
    End {
        ts: u64,
        #[allow(dead_code)]
        id: u64,
    },
    Enter {
        ts: u64,
        id: u64,
        thread_id: u64,
    },
    Exit {
        ts: u64,
        id: u64,
        thread_id: u64,
    },
    Event {
        ts: u64,
        parent: Option<u64>,
        #[serde(borrow)]
        values: Vec<(Cow<'a, str>, TraceValue<'a>)>,
    },
    Record {
        id: u64,
        #[serde(borrow)]
        values: Vec<(Cow<'a, str>, TraceValue<'a>)>,
    },
    #[allow(dead_code)]
    Allocation {
        ts: u64,
        thread_id: u64,
        allocations: u64,
        allocation_count: u64,
        deallocations: u64,
        deallocation_count: u64,
    },
    #[allow(dead_code)]
    AllocationCounters {
        ts: u64,
        thread_id: u64,
        allocations: u64,
        allocation_count: u64,
        deallocations: u64,
        deallocation_count: u64,
    },
}

#[derive(Debug, serde::Deserialize)]
enum TraceValue<'a> {
    String(#[serde(borrow)] Cow<'a, str>),
    Bool(bool),
    UInt(u64),
    Int(i64),
    Float(f64),
}

impl std::fmt::Display for TraceValue<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TraceValue::String(s) => write!(f, "{s}"),
            TraceValue::Bool(b) => write!(f, "{b}"),
            TraceValue::UInt(u) => write!(f, "{u}"),
            TraceValue::Int(i) => write!(f, "{i}"),
            TraceValue::Float(fl) => write!(f, "{fl}"),
        }
    }
}

// ── Errors ─────────────────────────────────────────────────────────────────

/// Errors that can occur during Turbopack trace conversion.
#[derive(Error, Debug)]
pub enum ConvertError {
    #[error("IO error: {0}")]
    Io(#[from] io::Error),

    #[error("postcard deserialization error: {0}")]
    Postcard(#[from] postcard::Error),

    #[error("SPAA write error: {0}")]
    Write(#[from] spaa_parse::WriteError),

    #[error("no spans found in trace")]
    NoSpans,
}

// ── Internal span model ────────────────────────────────────────────────────

struct Span {
    name: String,
    target: String,
    parent: Option<u64>,
    /// String args from Start `values` — used as identity qualifiers.
    /// e.g., [("name", "src/app/page.tsx"), ("lookup_path", "...")]
    args: Vec<(String, String)>,
    /// Numeric metrics from Record events — aggregated as weights.
    /// e.g., [("module_count", 42), ("total_size", 1024)]
    metrics: Vec<(String, u64)>,
    self_time_us: u64,
    self_allocations: u64,
    self_allocation_count: u64,
    self_deallocations: u64,
    self_deallocation_count: u64,
    children: Vec<u64>,
}

impl Span {
    /// Build a display name that incorporates identity args.
    ///
    /// If the span has string args, the most descriptive one is appended:
    /// `resolve_module [src/app/page.tsx]`
    ///
    /// This makes each (operation, subject) pair a distinct frame in the
    /// SPAA output, preserving per-file granularity.
    fn display_name(&self) -> String {
        // Pick the best identity arg. Prefer "name", then "lookup_path",
        // then fall back to the first string arg if any.
        let identity = self
            .args
            .iter()
            .find(|(k, _)| k == "name")
            .or_else(|| self.args.iter().find(|(k, _)| k == "lookup_path"))
            .or_else(|| self.args.first());

        match identity {
            Some((_, v)) if !v.is_empty() => format!("{} [{}]", self.name, v),
            _ => self.name.clone(),
        }
    }
}

#[derive(Default)]
struct ThreadAllocCounters {
    allocations: u64,
    allocation_count: u64,
    deallocations: u64,
    deallocation_count: u64,
}

// ── Converter ──────────────────────────────────────────────────────────────

/// Converter from Turbopack trace files to SPAA format.
pub struct TurbopackConverter {
    spans: HashMap<u64, Span>,
    thread_stacks: HashMap<u64, Vec<u64>>,
    self_time_started: HashMap<(u64, u64), u64>,
    thread_alloc_counters: HashMap<u64, ThreadAllocCounters>,
    thread_ids: HashSet<u64>,
    min_ts: u64,
    max_ts: u64,
    row_count: u64,
    synthetic_id_counter: u64,
}

impl TurbopackConverter {
    /// Create a new converter.
    pub fn new() -> Self {
        Self {
            spans: HashMap::new(),
            thread_stacks: HashMap::new(),
            self_time_started: HashMap::new(),
            thread_alloc_counters: HashMap::new(),
            thread_ids: HashSet::new(),
            min_ts: u64::MAX,
            max_ts: 0,
            row_count: 0,
            synthetic_id_counter: 0,
        }
    }

    /// Parse a turbopack trace file from a path.
    ///
    /// Handles `TRACEv0` magic prefix and optional zstd/gzip compression.
    pub fn parse_file<P: AsRef<Path>>(&mut self, path: P) -> Result<(), ConvertError> {
        let file = std::fs::File::open(path.as_ref())?;
        let mut reader = BufReader::with_capacity((1 << 17) + 7, file);

        // Peek at magic bytes for compression detection
        let mut magic = [0u8; 4];
        reader.read_exact(&mut magic)?;

        // Re-open cleanly
        drop(reader);
        let file = std::fs::File::open(path.as_ref())?;
        let reader = BufReader::with_capacity((1 << 17) + 7, file);
        let path_str = path.as_ref().to_string_lossy();

        if path_str.ends_with(".zst") || magic == [0x28, 0xb5, 0x2f, 0xfd] {
            let decoder = zstd::Decoder::with_buffer(reader)
                .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;
            self.parse_reader(decoder)
        } else if path_str.ends_with(".gz") || magic[..2] == [0x1f, 0x8b] {
            let decoder = flate2::bufread::GzDecoder::new(reader);
            self.parse_reader(decoder)
        } else {
            self.parse_reader(reader)
        }
    }

    /// Parse from any reader (already decompressed).
    pub fn parse_reader<R: Read>(&mut self, mut reader: R) -> Result<(), ConvertError> {
        let mut data = Vec::new();
        let mut chunk = vec![0u8; 64 * 1024 * 1024];
        loop {
            let n = reader.read(&mut chunk)?;
            if n == 0 {
                break;
            }
            data.extend_from_slice(&chunk[..n]);
        }

        // Skip TRACEv0 magic if present
        let mut offset = 0;
        if data.starts_with(b"TRACEv0") {
            offset = 7;
        }

        let mut buf = &data[offset..];
        loop {
            match postcard::take_from_bytes::<TraceRow>(buf) {
                Ok((row, remaining)) => {
                    self.process_row(row);
                    buf = remaining;
                    self.row_count += 1;
                }
                Err(postcard::Error::DeserializeUnexpectedEnd) => break,
                Err(e) => {
                    if self.row_count > 0 {
                        // Partial read is OK — trace may still be in progress
                        eprintln!(
                            "Warning: parse error after {} events: {e}",
                            self.row_count
                        );
                        break;
                    }
                    return Err(e.into());
                }
            }
        }

        Ok(())
    }

    fn next_synthetic_id(&mut self) -> u64 {
        self.synthetic_id_counter += 1;
        u64::MAX - self.synthetic_id_counter
    }

    fn update_ts(&mut self, ts: u64) {
        if ts > 0 && ts < self.min_ts {
            self.min_ts = ts;
        }
        if ts > self.max_ts {
            self.max_ts = ts;
        }
    }

    /// Classify trace values into string args and numeric metrics.
    fn classify_values(
        values: &[(Cow<'_, str>, TraceValue<'_>)],
    ) -> (Vec<(String, String)>, Vec<(String, u64)>) {
        let mut args = Vec::new();
        let mut metrics = Vec::new();
        for (k, v) in values {
            match v {
                TraceValue::String(s) => {
                    args.push((k.to_string(), s.to_string()));
                }
                TraceValue::UInt(n) => {
                    metrics.push((k.to_string(), *n));
                }
                TraceValue::Int(n) if *n >= 0 => {
                    metrics.push((k.to_string(), *n as u64));
                }
                TraceValue::Bool(b) => {
                    args.push((k.to_string(), b.to_string()));
                }
                _ => {
                    // Float and negative Int — store as string args
                    args.push((k.to_string(), v.to_string()));
                }
            }
        }
        (args, metrics)
    }

    fn process_row(&mut self, row: TraceRow<'_>) {
        match row {
            TraceRow::Start {
                ts,
                id,
                parent,
                name,
                target,
                values,
            } => {
                self.update_ts(ts);
                let (args, metrics) = Self::classify_values(&values);
                let span = Span {
                    name: name.into_owned(),
                    target: target.into_owned(),
                    parent,
                    args,
                    metrics,
                    self_time_us: 0,
                    self_allocations: 0,
                    self_allocation_count: 0,
                    self_deallocations: 0,
                    self_deallocation_count: 0,
                    children: Vec::new(),
                };
                self.spans.insert(id, span);
                if let Some(pid) = parent {
                    if let Some(parent_span) = self.spans.get_mut(&pid) {
                        parent_span.children.push(id);
                    }
                }
            }
            TraceRow::End { ts, .. } => {
                self.update_ts(ts);
            }
            TraceRow::Enter { ts, id, thread_id } => {
                self.update_ts(ts);
                self.thread_ids.insert(thread_id);
                let stack = self.thread_stacks.entry(thread_id).or_default();
                if let Some(&parent_id) = stack.last() {
                    if let Some(parent_start) =
                        self.self_time_started.remove(&(parent_id, thread_id))
                    {
                        if ts > parent_start {
                            if let Some(parent_span) = self.spans.get_mut(&parent_id) {
                                parent_span.self_time_us += ts - parent_start;
                            }
                        }
                    }
                }
                stack.push(id);
                self.self_time_started.insert((id, thread_id), ts);
            }
            TraceRow::Exit { ts, id, thread_id } => {
                self.update_ts(ts);
                let stack = self.thread_stacks.entry(thread_id).or_default();
                if let Some(pos) = stack.iter().rev().position(|&x| x == id) {
                    let stack_index = stack.len() - pos - 1;
                    stack.remove(stack_index);
                    if stack_index > 0 {
                        let parent_id = stack[stack_index - 1];
                        self.self_time_started.insert((parent_id, thread_id), ts);
                    }
                }
                if let Some(start) = self.self_time_started.remove(&(id, thread_id)) {
                    if ts > start {
                        if let Some(span) = self.spans.get_mut(&id) {
                            span.self_time_us += ts - start;
                        }
                    }
                }
            }
            TraceRow::Event {
                ts,
                parent,
                values,
            } => {
                self.update_ts(ts);
                let mut name = String::from("event");
                let mut duration = 0u64;
                let mut extra_args = Vec::new();
                for (k, v) in &values {
                    match k.as_ref() {
                        "name" => {
                            if let TraceValue::String(s) = v {
                                name = s.to_string();
                            }
                        }
                        "duration" => {
                            if let TraceValue::UInt(d) = v {
                                duration = *d;
                            }
                        }
                        _ => {
                            extra_args.push((k.to_string(), v.to_string()));
                        }
                    }
                }
                let synthetic_id = self.next_synthetic_id();
                let span = Span {
                    name,
                    target: "event".to_string(),
                    parent,
                    args: extra_args,
                    metrics: Vec::new(),
                    self_time_us: duration,
                    self_allocations: 0,
                    self_allocation_count: 0,
                    self_deallocations: 0,
                    self_deallocation_count: 0,
                    children: Vec::new(),
                };
                self.spans.insert(synthetic_id, span);
                if let Some(pid) = parent {
                    if let Some(parent_span) = self.spans.get_mut(&pid) {
                        parent_span.children.push(synthetic_id);
                    }
                }
            }
            TraceRow::Record { id, values } => {
                if let Some(span) = self.spans.get_mut(&id) {
                    let (args, metrics) = Self::classify_values(&values);
                    span.args.extend(args);
                    span.metrics.extend(metrics);
                }
            }
            TraceRow::Allocation {
                thread_id,
                allocations,
                allocation_count,
                deallocations,
                deallocation_count,
                ..
            } => {
                self.thread_ids.insert(thread_id);
                let stack = self.thread_stacks.entry(thread_id).or_default();
                if let Some(&id) = stack.last() {
                    if let Some(span) = self.spans.get_mut(&id) {
                        span.self_allocations += allocations;
                        span.self_allocation_count += allocation_count;
                        span.self_deallocations += deallocations;
                        span.self_deallocation_count += deallocation_count;
                    }
                }
            }
            TraceRow::AllocationCounters {
                thread_id,
                allocations,
                allocation_count,
                deallocations,
                deallocation_count,
                ..
            } => {
                self.thread_ids.insert(thread_id);
                let prev = self.thread_alloc_counters.entry(thread_id).or_default();
                let diff_alloc = allocations.saturating_sub(prev.allocations);
                let diff_alloc_count = allocation_count.saturating_sub(prev.allocation_count);
                let diff_dealloc = deallocations.saturating_sub(prev.deallocations);
                let diff_dealloc_count =
                    deallocation_count.saturating_sub(prev.deallocation_count);
                prev.allocations = allocations;
                prev.allocation_count = allocation_count;
                prev.deallocations = deallocations;
                prev.deallocation_count = deallocation_count;

                let stack = self.thread_stacks.entry(thread_id).or_default();
                if let Some(&id) = stack.last() {
                    if let Some(span) = self.spans.get_mut(&id) {
                        span.self_allocations += diff_alloc;
                        span.self_allocation_count += diff_alloc_count;
                        span.self_deallocations += diff_dealloc;
                        span.self_deallocation_count += diff_dealloc_count;
                    }
                }
            }
        }
    }

    /// Number of trace events parsed.
    pub fn row_count(&self) -> u64 {
        self.row_count
    }

    /// Number of spans in the trace.
    pub fn span_count(&self) -> usize {
        self.spans.len()
    }

    /// Whether any allocation data was found.
    pub fn has_allocations(&self) -> bool {
        self.spans
            .values()
            .any(|s| s.self_allocations > 0 || s.self_deallocations > 0)
    }

    /// Write the parsed trace as SPAA format.
    pub fn write_spaa<W: Write>(&self, writer: W) -> Result<(), ConvertError> {
        if self.spans.is_empty() {
            return Err(ConvertError::NoSpans);
        }

        let has_allocs = self.has_allocations();
        let mut w = SpaaWriter::new(writer);

        // ── Header ─────────────────────────────────────────────────────
        let mut events = vec![EventDef {
            name: "turbopack-self-time".to_string(),
            kind: EventKind::Timer,
            sampling: Sampling {
                mode: SamplingMode::Event,
                primary_metric: "self_time_us".to_string(),
                sample_period: None,
                frequency_hz: None,
            },
            allocation_tracking: None,
        }];
        if has_allocs {
            events.push(EventDef {
                name: "turbopack-allocations".to_string(),
                kind: EventKind::Allocation,
                sampling: Sampling {
                    mode: SamplingMode::Event,
                    primary_metric: "alloc_bytes".to_string(),
                    sample_period: None,
                    frequency_hz: None,
                },
                allocation_tracking: Some(AllocationTracking {
                    tracks_frees: true,
                    has_timestamps: false,
                }),
            });
        }

        let header = Header {
            format: "spaa".to_string(),
            version: "1.0".to_string(),
            source_tool: "turbopack".to_string(),
            frame_order: FrameOrder::LeafToRoot,
            events,
            time_range: Some(TimeRange {
                start: self.min_ts as f64 / 1_000_000.0,
                end: self.max_ts as f64 / 1_000_000.0,
                unit: "seconds".to_string(),
            }),
            source: Some(SourceInfo {
                tool: "turbopack_to_spaa".to_string(),
                command: Some("turbopack_to_spaa <trace-file>".to_string()),
                tool_version: Some(env!("CARGO_PKG_VERSION").to_string()),
            }),
            stack_id_mode: StackIdMode::ContentAddressable,
        };
        w.write_header(&header)?;

        // ── Build frame + DSO dictionaries ─────────────────────────────
        //
        // Frame identity = (display_name, target). The display_name includes
        // identity args, so "resolve_module [src/app/page.tsx]" is a
        // different frame from "resolve_module [src/components/Button.tsx]".
        let mut frame_map: HashMap<(String, String), u64> = HashMap::new();
        let mut dso_map: HashMap<String, u64> = HashMap::new();
        let mut next_frame_id = 1u64;
        let mut next_dso_id = 1u64;

        // First pass: register all unique DSOs and frames.
        // We need per-span frame IDs, so also build a span->frame lookup.
        let mut span_frame_ids: HashMap<u64, u64> = HashMap::new();

        for (&span_id, span) in &self.spans {
            if !dso_map.contains_key(&span.target) {
                dso_map.insert(span.target.clone(), next_dso_id);
                next_dso_id += 1;
            }
            let display = span.display_name();
            let key = (display, span.target.clone());
            let frame_id = *frame_map.entry(key).or_insert_with(|| {
                let id = next_frame_id;
                next_frame_id += 1;
                id
            });
            span_frame_ids.insert(span_id, frame_id);
        }

        // ── Write DSOs ─────────────────────────────────────────────────
        let mut dsos: Vec<_> = dso_map.iter().collect();
        dsos.sort_by_key(|(_, id)| **id);
        for (name, id) in &dsos {
            w.write_dso(&Dso {
                id: **id,
                name: name.to_string(),
                build_id: None,
                is_kernel: false,
            })?;
        }

        // ── Write frames ───────────────────────────────────────────────
        let mut frames: Vec<_> = frame_map.iter().collect();
        frames.sort_by_key(|(_, id)| **id);
        for ((name, target), id) in &frames {
            w.write_frame(&Frame {
                id: **id,
                func: name.clone(),
                dso: dso_map[target],
                func_resolved: true,
                ip: None,
                symoff: None,
                srcline: None,
                srcline_resolved: true,
                inlined: false,
                inline_depth: None,
                kind: FrameKind::User,
            })?;
        }

        // ── Write threads ──────────────────────────────────────────────
        let mut tids: Vec<_> = self.thread_ids.iter().copied().collect();
        tids.sort();
        for tid in &tids {
            w.write_thread(&Thread {
                pid: 0,
                tid: *tid,
                comm: Some(format!("thread-{tid}")),
            })?;
        }

        // ── Build and aggregate stacks ─────────────────────────────────
        struct StackAgg {
            self_time_us: u64,
            alloc_bytes: u64,
            alloc_count: u64,
            dealloc_bytes: u64,
            dealloc_count: u64,
            /// Aggregated numeric metrics from Record events.
            /// Key = metric name, value = sum across all spans with this stack.
            record_metrics: HashMap<String, u64>,
        }

        let mut stack_agg: HashMap<Vec<u64>, StackAgg> = HashMap::new();

        for (&span_id, span) in &self.spans {
            let has_time = span.self_time_us > 0;
            let has_mem = span.self_allocations > 0 || span.self_deallocations > 0;
            let has_metrics = !span.metrics.is_empty();
            if !has_time && !has_mem && !has_metrics {
                continue;
            }

            let call_stack = self.build_call_stack(span_id, &span_frame_ids);
            if call_stack.is_empty() {
                continue;
            }

            let entry = stack_agg.entry(call_stack).or_insert(StackAgg {
                self_time_us: 0,
                alloc_bytes: 0,
                alloc_count: 0,
                dealloc_bytes: 0,
                dealloc_count: 0,
                record_metrics: HashMap::new(),
            });
            entry.self_time_us += span.self_time_us;
            entry.alloc_bytes += span.self_allocations;
            entry.alloc_count += span.self_allocation_count;
            entry.dealloc_bytes += span.self_deallocations;
            entry.dealloc_count += span.self_deallocation_count;
            for (k, v) in &span.metrics {
                *entry.record_metrics.entry(k.clone()).or_insert(0) += v;
            }
        }

        // Sort by self_time descending
        let mut stacks: Vec<_> = stack_agg.into_iter().collect();
        stacks.sort_by(|a, b| b.1.self_time_us.cmp(&a.1.self_time_us));

        for (call_stack, agg) in &stacks {
            let stack_id = hash_stack(call_stack);
            let leaf_frame = call_stack[0];

            let mut weights = Vec::new();
            if agg.self_time_us > 0 {
                weights.push(Weight {
                    metric: "self_time_us".to_string(),
                    value: agg.self_time_us,
                    unit: Some("microseconds".to_string()),
                });
            }
            if agg.alloc_bytes > 0 {
                weights.push(Weight {
                    metric: "alloc_bytes".to_string(),
                    value: agg.alloc_bytes,
                    unit: Some("bytes".to_string()),
                });
                weights.push(Weight {
                    metric: "alloc_count".to_string(),
                    value: agg.alloc_count,
                    unit: None,
                });
            }
            if agg.dealloc_bytes > 0 {
                weights.push(Weight {
                    metric: "free_bytes".to_string(),
                    value: agg.dealloc_bytes,
                    unit: Some("bytes".to_string()),
                });
                weights.push(Weight {
                    metric: "free_count".to_string(),
                    value: agg.dealloc_count,
                    unit: None,
                });
            }
            if agg.alloc_bytes > 0 || agg.dealloc_bytes > 0 {
                let live = agg.alloc_bytes.saturating_sub(agg.dealloc_bytes);
                if live > 0 {
                    weights.push(Weight {
                        metric: "live_bytes".to_string(),
                        value: live,
                        unit: Some("bytes".to_string()),
                    });
                }
            }
            // Add aggregated Record metrics as additional weights
            let mut sorted_metrics: Vec<_> = agg.record_metrics.iter().collect();
            sorted_metrics.sort_by_key(|(k, _)| (*k).clone());
            for (k, v) in sorted_metrics {
                if *v > 0 {
                    weights.push(Weight {
                        metric: k.clone(),
                        value: *v,
                        unit: None,
                    });
                }
            }

            // Skip stacks with no weights at all
            if weights.is_empty() {
                continue;
            }

            let event = if agg.self_time_us > 0 {
                "turbopack-self-time"
            } else {
                "turbopack-allocations"
            };

            w.write_stack(&Stack {
                id: stack_id,
                frames: call_stack.clone(),
                stack_type: StackType::Unified,
                context: StackContext {
                    event: event.to_string(),
                    pid: None,
                    tid: None,
                    cpu: None,
                    comm: None,
                    probe: None,
                    execname: None,
                    uid: None,
                    zonename: None,
                    trace_fields: None,
                    extra: HashMap::new(),
                },
                weights: weights.clone(),
                exclusive: Some(ExclusiveWeights {
                    frame: leaf_frame,
                    weights,
                }),
                related_stacks: None,
            })?;
        }

        Ok(())
    }

    /// Walk the parent chain from a span to the root, collecting frame IDs.
    /// Returns frames in leaf-to-root order.
    fn build_call_stack(
        &self,
        span_id: u64,
        span_frame_ids: &HashMap<u64, u64>,
    ) -> Vec<u64> {
        let mut stack = Vec::new();
        let mut current = Some(span_id);
        let mut visited = HashSet::new();
        while let Some(id) = current {
            if !visited.insert(id) {
                break;
            }
            if let Some(span) = self.spans.get(&id) {
                if let Some(&frame_id) = span_frame_ids.get(&id) {
                    stack.push(frame_id);
                }
                current = span.parent;
            } else {
                break;
            }
        }
        stack
    }
}

impl Default for TurbopackConverter {
    fn default() -> Self {
        Self::new()
    }
}

/// FNV-1a hash of frame IDs for content-addressable stack IDs.
fn hash_stack(frames: &[u64]) -> String {
    let mut h: u64 = 0xcbf29ce484222325;
    for &f in frames {
        for b in f.to_le_bytes() {
            h ^= b as u64;
            h = h.wrapping_mul(0x100000001b3);
        }
    }
    format!("0x{h:016x}")
}
