//! Convert Turbopack trace files to SPAA format.
//!
//! This binary reads Turbopack trace files generated by
//! `NEXT_TURBOPACK_TRACING=1 npm run dev` and converts them to SPAA.
//!
//! # Usage
//!
//! ```bash
//! turbopack_to_spaa .next/trace-turbopack -o profile.spaa
//! turbopack_to_spaa trace-turbopack.zst
//! ```

use clap::Parser;
use spaa::turbopack::TurbopackConverter;
use std::fs::File;
use std::io::{self, BufWriter, Write};
use std::path::PathBuf;
use std::process::ExitCode;

#[derive(Parser, Debug)]
#[command(name = "turbopack_to_spaa")]
#[command(about = "Convert Turbopack trace files to SPAA format")]
#[command(version)]
struct Args {
    /// Path to the turbopack trace file (.trace, .trace.zst, .trace.gz)
    input: PathBuf,

    /// Output SPAA file (defaults to stdout)
    #[arg(short, long)]
    output: Option<PathBuf>,
}

fn run(args: Args) -> Result<(), Box<dyn std::error::Error>> {
    eprintln!("Opening trace file: {}", args.input.display());

    let mut converter = TurbopackConverter::new();
    converter.parse_file(&args.input)?;

    eprintln!(
        "Parsed {} events, {} spans",
        converter.row_count(),
        converter.span_count()
    );

    let mut out: Box<dyn Write> = if let Some(path) = &args.output {
        Box::new(BufWriter::new(File::create(path)?))
    } else {
        Box::new(BufWriter::new(io::stdout()))
    };

    converter.write_spaa(&mut out)?;
    out.flush()?;

    if converter.has_allocations() {
        eprintln!("Wrote SPAA output (includes allocation data)");
    } else {
        eprintln!("Wrote SPAA output");
    }

    Ok(())
}

fn main() -> ExitCode {
    let args = Args::parse();
    match run(args) {
        Ok(()) => ExitCode::SUCCESS,
        Err(e) => {
            eprintln!("Error: {e}");
            ExitCode::FAILURE
        }
    }
}
